/*******************************************************************************
*
* INTEL HEX FILE CLASS MODULE
*
*******************************************************************************/

/******************************************************************************/
/*!
* \file intelhexclass.cpp
* \mainpage
* \image html intelhexclass.png
* \image latex intelhexclass.eps
* \section intro Introduction
* The Intel HEX File class module is designed to encode, decode and manipulate 
* the content of Intel HEX format files commonly generated by most toolchains
* for embedded processors and microcontrollers.
*
* It uses standard C++ streams to decode files and store them in memory, and 
* encode data stored in memory back into an Intel HEX format file. Once the file
* content is in memory, the content can then be manipulated using the available
* API.
*
* With this class it is possible to create tools that can compare Intel HEX
* files, fill empty space with desired values, splice two or more files 
* together to name a few possibilities.
*
* \section contactInfo Contact Information
* For more information and the latest release, please visit this projects home
* page at http://codinghead.github.com/Intel-HEX-Class
* To participate in the project or for other enquiries, please contact Stuart
* Cording at codinghead@gmail.com
*
* \section license Licensing Information
* Copyright (c) 2012 Stuart Cording
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* \section imageInfo Image Information
* Image chosen for this project comes from 'Henkster'. Original image is from
* http://www.sxc.hu/photo/504350 on stock.xchng. 
*
* \author Stuart Cording aka CODINGHEAD
*
********************************************************************************
* \note
* No notes to date (19th Jan 2012)
*******************************************************************************/

#include "intelhexclass.h"

#include <iostream>
#include <vector>

using namespace std;

namespace intelhex {
/******************************************************************************/
/*! Possible record types for Intel HEX file.
*
* List of all possible record types that can be found in an Intel HEX file.
*******************************************************************************/
enum intelhexRecordType {
    DATA_RECORD,
    END_OF_FILE_RECORD,
    EXTENDED_SEGMENT_ADDRESS,
    START_SEGMENT_ADDRESS,
    EXTENDED_LINEAR_ADDRESS,
    START_LINEAR_ADDRESS,
    NO_OF_RECORD_TYPES
};

/*******************************************************************************
* Converts an std::uint32_t to a string in HEX format
*******************************************************************************/
string intelhex::ulToHexString(std::uint32_t value) {
    string returnString;
    char localString[50];

    returnString.erase();

#ifdef _MSC_FULL_VER
    sprintf_s(localString, 49, "%08lX", value);
#else
    snprintf(localString, 49, "%08uX", value);
#endif

    returnString.insert(0, localString);

    return returnString;
}

/*******************************************************************************
* Converts an std::uint8_t to a string in HEX format
*******************************************************************************/
string intelhex::ucToHexString(std::uint8_t value) {
    string returnString;
    char localString[50];

    returnString.erase();

#ifdef _MSC_FULL_VER
    sprintf_s(localString, 49, "%02X", value);
#else
    snprintf(localString, 49, "%02X", value);
#endif

    returnString.insert(0, localString);

    return returnString;
}

/*******************************************************************************
* Adds a warning to the list of warning messages
*******************************************************************************/
void intelhex::addWarning(string warningMessage) {
    string localMessage;

    /* Build the message and push the warning message onto the list           */
    localMessage += std::to_string(msgWarning.noOfWarnings + 1) + " Warning: "
                    + warningMessage;

    msgWarning.ihWarnings.push_back(localMessage);

    /* Update the number of warning messages                                  */
    msgWarning.noOfWarnings = msgWarning.ihWarnings.size();
}

/*******************************************************************************
* Adds an error to the list of error messages
*******************************************************************************/
void intelhex::addError(string errorMessage) {
    string localMessage;

    /* Build the message and push the error message onto the list             */
    localMessage += std::to_string(msgError.noOfErrors + 1) + " Error: "
                    + errorMessage;

    msgError.ihErrors.push_back(localMessage);

    /* Update the number of error messages                                    */
    msgError.noOfErrors = msgError.ihErrors.size();
}

/*******************************************************************************
* Decodes a data record read in from a file
*******************************************************************************/
void intelhex::decodeDataRecord(std::uint8_t recordLength,
                                std::uint32_t loadOffset,
                                string::const_iterator data) {
    /* Variable to store a byte of the record as a two char string            */
    string sByteRead;

    /* Variable to store the byte of the record as an u.char                  */
    std::uint8_t byteRead;

    /* Calculate new SBA by clearing the low four bytes and then adding the   */
    /* current loadOffset for this line of Intel HEX data                     */
    segmentBaseAddress &= ~(0xFFFFUL);
    segmentBaseAddress += loadOffset;

    for (std::uint8_t x = 0; x < recordLength; x++) {
        sByteRead.erase();

        sByteRead = *data;
        data++;
        sByteRead += *data;
        data++;

        byteRead = std::stoul(sByteRead, 0, 16);

        ihReturn = ihContent.insert(
                pair<int, std::uint8_t>(segmentBaseAddress, byteRead));

        if (! ihReturn.second) {
            /* If this address already contains the byte we are trying to     */
            /* write, this is only a warning                                  */
            if (ihReturn.first->second == byteRead) {
                string message;

                message = "Location 0x" + ulToHexString(segmentBaseAddress) +
                          " already contains data 0x" + sByteRead;

                addWarning(message);
            }
                /* Otherwise this is an error                                     */
            else {
                string message;

                message = "Couldn't add 0x" + sByteRead + " @ 0x" +
                          ulToHexString(segmentBaseAddress) +
                          "; already contains 0x" +
                          ucToHexString(ihReturn.first->second);

                addError(message);
            }
        }

        /* Increment the segment base address                                 */
        ++segmentBaseAddress;
    }
}

/*******************************************************************************
* Input Stream for Intel HEX File Decoding (friend function)
*******************************************************************************/
istream &operator>>(istream &dataIn, intelhex &ihLocal) {
    /* Create a string to store a single byte of Intel HEX info               */
    // Create a line counter
    std::uint32_t lineCounter = 0;
    // Variable to hold a single byte (two chars) of data
    std::uint8_t byteRead;
    // Variable to hold the record length
    //std::uint8_t recordLength;
    // Variable to hold the load offset
    //std::uint32_t loadOffset;
    // Variables to hold the record type
    intelhexRecordType recordType;


    // A string to store lines of Intel Hex info
    std::string ihLine;
    do {
        ihLine.clear();

        /* Get a line of data                                                 */
        dataIn >> ihLine;

        /* If the line contained some data, process it                        */
        if (ihLine.length() > 0) {
            /* Increment line counter                                         */
            lineCounter++;

            /* Check that we have a ':' record mark at the beginning          */
            if (ihLine.front() != ':') {
                ihLocal.addWarning("Line without record mark ':' found @ line " + std::to_string(lineCounter));

                /* If this is the first line, let's simply give up. Chances   */
                /* are this is not an Intel HEX file at all                   */
                if (lineCounter == 1) {
                    ihLocal.addError("Intel HEX File decode aborted; ':' missing in first line.");

                    /* Erase ihLine content and break out of do...while loop  */
                    ihLine.clear();
                    break;
                }
            }else {
                /* Remove the record mark from the string as we don't need it */
                /* anymore                                                    */
                ihLine.erase(ihLine.begin());
            }

            if (ihLine.length() % 2) {
                // Odd number of charactes in line
                ihLocal.addError("Odd number of characters in line " + std::to_string(lineCounter));
            } else {
                std::uint8_t intelHexChecksum = 0;
                /* Run through the whole line to check the checksum               */
                for (auto it = ihLine.cbegin(); it != ihLine.cend(); it+=2) {
                    byteRead = std::stoul(std::string(it, it+2), 0, 16);
                    intelHexChecksum += byteRead;
                }

                // Make sure the checksum was ok
                if (intelHexChecksum) {
                    ihLocal.addError(
                            "Checksum error @ line " + std::to_string(lineCounter) + "; calculated 0x"
                                    + ihLocal.ucToHexString(intelHexChecksum - byteRead) + " expected 0x"
                                    + ihLocal.ucToHexString(byteRead));
                } else {
                    /* Reset iterator back to beginning of the line so we can now */
                    /* decode it                                                  */
                    auto it = ihLine.begin();

                    /* Get the record length                                      */
                    std::uint8_t recordLength = std::stoul(std::string(it, it+2), 0, 16);
                    it+=2;

                    /* Get the load offset (2 bytes)                              */
                    std::uint32_t loadOffset = std::stoul(std::string(it, it+4), 0, 16);
                    it+=4;

                    /* Get the record type                                        */
                    recordType = static_cast<intelhexRecordType>(std::stoul(std::string(it, it+2), 0, 16));
                    it+=2;

                    /* Decode the INFO or DATA portion of the record              */
                    switch (recordType) {
                    case DATA_RECORD:
                        ihLocal.decodeDataRecord(recordLength, loadOffset, it);
                        if (ihLocal.verbose) {
                            cout << "Data Record begining @ 0x" << ihLocal.ulToHexString(loadOffset) << endl;
                        }
                        break;

                    case END_OF_FILE_RECORD:
                        /* Check that the EOF record wasn't already found. If */
                        /* it was, generate appropriate error                 */
                        if (!ihLocal.foundEof) {
                            ihLocal.foundEof = true;
                        } else {
                            ihLocal.addError("Additional End Of File record @ line " + std::to_string(lineCounter) + " found.");
                        }
                        /* Generate error if there were                       */
                        if (ihLocal.verbose) {
                            cout << "End of File\n";
                        }
                        break;

                    case EXTENDED_SEGMENT_ADDRESS:
                        /* Make sure we have 2 bytes of data                  */
                        if (recordLength == 2) {
                            /* Extract the two bytes of the ESA               */
                            std::uint32_t extSegAddress = std::stoul(std::string(it, it+4), 0, 16);
                            it+=4;

                            /* ESA is bits 4-19 of the segment base address   */
                            /* (SBA), so shift left 4 bits                    */
                            extSegAddress <<= 4;

                            /* Update the SBA                                 */
                            ihLocal.segmentBaseAddress = extSegAddress;
                        } else {
                            /* Note the error                                 */
                            ihLocal.addError("Extended Segment Address @ line " + std::to_string(lineCounter) + " not 2 bytes as required.");
                        }
                        if (ihLocal.verbose) {
                            cout << "Ext. Seg. Address found: 0x" << ihLocal.ulToHexString(ihLocal.segmentBaseAddress)
                                    << "\n";
                        }

                        break;

                    case START_SEGMENT_ADDRESS:
                        /* Make sure we have 4 bytes of data, and that no     */
                        /* Start Segment Address has been found to date       */
                        if (recordLength == 4 && (!ihLocal.startSegmentAddress.exists)) {
                            /* Note that the Start Segment Address has been   */
                            /* found.                                         */
                            ihLocal.startSegmentAddress.exists = true;

                            ihLocal.startSegmentAddress.csRegister = std::stoul(std::string(it, it+4), 0, 16);
                            it+=4;

                            ihLocal.startSegmentAddress.ipRegister = std::stoul(std::string(it, it+4), 0, 16);
                            it+=4;
                        }
                        /* Note an error if the start seg. address already    */
                        /* exists                                             */
                        else if (ihLocal.startSegmentAddress.exists) {
                            ihLocal.addError("Start Segment Address record appears again @ line " + std::to_string(lineCounter)
                            + "; repeated record ignored.");
                        }
                        /* Note an error if the start lin. address already    */
                        /* exists as they should be mutually exclusive        */
                        if (ihLocal.startLinearAddress.exists) {
                            ihLocal.addError("Start Segment Address record found @ line " + std::to_string(lineCounter)
                            + " but Start Linear Address already exists.");
                        }
                        /* Note an error if the record lenght is not 4 as     */
                        /* expected                                           */
                        if (recordLength != 4) {
                            ihLocal.addError("Start Segment Address @ line " + std::to_string(lineCounter)
                            + " not 4 bytes as required.");
                        }

                        if (ihLocal.verbose) {
                            cout << "Start Seg. Address - CS 0x"
                                    << ihLocal.ulToHexString(ihLocal.startSegmentAddress.csRegister) << " IP 0x"
                                    << ihLocal.ulToHexString(ihLocal.startSegmentAddress.ipRegister) << "\n";
                        }
                        break;

                    case EXTENDED_LINEAR_ADDRESS:
                        /* Make sure we have 2 bytes of data                  */
                        if (recordLength == 2) {
                            /* Extract the two bytes of the ELA               */
                            std::uint32_t extLinAddress = std::stoul(std::string(it, it+4), 0, 16);
                            it+=4;

                            /* ELA is bits 16-31 of the segment base address  */
                            /* (SBA), so shift left 16 bits                   */
                            extLinAddress <<= 16;

                            /* Update the SBA                                 */
                            ihLocal.segmentBaseAddress = extLinAddress;
                        } else {
                            /* Note the error                                 */
                            //cout << "Error in Ext. Lin. Address" << endl;
                            ihLocal.addError("Extended Linear Address @ line " + std::to_string(lineCounter)
                            + " not 2 bytes as required.");
                        }

                        if (ihLocal.verbose) {
                            cout << "Ext. Lin. Address 0x" << ihLocal.ulToHexString(ihLocal.segmentBaseAddress) << "\n";
                        }

                        break;

                    case START_LINEAR_ADDRESS:
                        /* Make sure we have 4 bytes of data                  */
                        if (recordLength == 4 && (!ihLocal.startLinearAddress.exists)) {
                            /* Extract the four bytes of the SLA              */
                            ihLocal.startLinearAddress.eipRegister = std::stoul(std::string(it, it+8), 0, 16);
                            it+=8;
                        }
                        /* Note an error if the start seg. address already    */
                        /* exists                                             */
                        else if (ihLocal.startLinearAddress.exists) {
                            ihLocal.addError("Start Linear Address record appears again @ line " + std::to_string(lineCounter)
                            + "; repeated record ignored.");
                        }
                        /* Note an error if the start seg. address already    */
                        /* exists as they should be mutually exclusive        */
                        if (ihLocal.startSegmentAddress.exists) {
                            ihLocal.addError("Start Linear Address record found @ line " + std::to_string(lineCounter)
                            + " but Start Segment Address already exists.");
                        }
                        /* Note an error if the record lenght is not 4 as     */
                        /* expected                                           */
                        if (recordLength != 4) {
                            ihLocal.addError("Start Linear Address @ line " + std::to_string(lineCounter)
                            + " not 4 bytes as required.");
                        }
                        if (ihLocal.verbose) {
                            cout << "Start Lin. Address - EIP 0x"
                                    << ihLocal.ulToHexString(ihLocal.startLinearAddress.eipRegister) << "\n";
                        }
                        break;

                    default:
                        /* Handle the error here                              */
                        if (ihLocal.verbose) {
                            cout << "Unknown Record @ line " << std::to_string(lineCounter) << "\n";
                        }

                        ihLocal.addError("Unknown Intel HEX record @ line " + std::to_string(lineCounter));

                        break;
                    }
                }
            }
        }
    } while (ihLine.length() > 0);

    if (ihLocal.verbose) {
        cout << "Decoded " << lineCounter << " lines from file.\n";
    }

    return (dataIn);
}

/*******************************************************************************
* Output Stream for Intel HEX File Encoding (friend function)
*******************************************************************************/
ostream &operator<<(ostream &dataOut, intelhex &ihLocal) {
    /* Stores the address offset needed by the linear/segment address records */
    std::uint32_t addressOffset;
    /* Iterator into the ihContent - where the addresses & data are stored    */
    intelhex::container_iterator_t ihIterator;
    /* Holds string that represents next record to be written                 */
    string thisRecord;
    /* Checksum calculation variable                                          */
    std::uint8_t checksum;

    thisRecord.clear();

    /* Check that there is some content to encode */
    if (ihLocal.ihContent.size() > 0) {
        /* Calculate the Linear/Segment address                               */
        ihIterator = ihLocal.ihContent.begin();
        addressOffset = (*ihIterator).first;
        checksum = 0;

        /* Construct the first record to define the segment base address      */
        if (! ihLocal.segmentAddressMode) {
            std::uint8_t dataByte;

            addressOffset >>= 16;

            thisRecord = ":02000004";
            checksum = 0x02 + 0x04;

            dataByte = static_cast<std::uint8_t>(addressOffset & 0xFF);
            checksum += dataByte;
            thisRecord += ihLocal.ucToHexString(dataByte);

            dataByte = static_cast<std::uint8_t>((addressOffset >> 8) & 0xFF);
            checksum += dataByte;
            thisRecord += ihLocal.ucToHexString(dataByte);

            thisRecord += ihLocal.ucToHexString(0x00 - (checksum & 0xFF));
        }
        else {
            std::uint8_t dataByte;

            addressOffset >>= 4;

            thisRecord = ":02000002";
            checksum = 0x02 + 0x02;

            dataByte = static_cast<std::uint8_t>(addressOffset & 0xFF);
            checksum += dataByte;
            thisRecord += ihLocal.ucToHexString(dataByte);

            dataByte = static_cast<std::uint8_t>((addressOffset >> 8) & 0xFF);
            checksum += dataByte;
            thisRecord += ihLocal.ucToHexString(dataByte);

            thisRecord += ihLocal.ucToHexString(0x00 - (checksum & 0xFF));
        }

        /* Output the record                                                  */
        dataOut << thisRecord << endl;

        /* Now loop through all the available data and insert into file       */
        /* with maximum 16 bytes per line, and making sure to keep the        */
        /* segment base address up to date                                    */
        vector<std::uint8_t> recordData;
        std::uint32_t previousAddress;
        std::uint32_t currentAddress;
        std::uint32_t loadOffset;

        while (ihIterator != ihLocal.ihContent.end()) {
            /* Check to see if we need to start a new linear/segment section  */
            loadOffset = (*ihIterator).first;

            /* If we are using the linear mode...                             */
            if (! ihLocal.segmentAddressMode) {
                if ((loadOffset >> 16) != addressOffset) {
                    std::uint8_t dataByte;

                    thisRecord.clear();
                    checksum = 0;

                    addressOffset = loadOffset;
                    addressOffset >>= 16;

                    thisRecord = ":02000004";
                    checksum = 0x02 + 0x04;

                    dataByte = static_cast<std::uint8_t>(addressOffset & 0xFF);
                    checksum += dataByte;
                    thisRecord += ihLocal.ucToHexString(dataByte);

                    dataByte = static_cast<std::uint8_t>((addressOffset >> 8) & 0xFF);
                    checksum += dataByte;
                    thisRecord += ihLocal.ucToHexString(dataByte);

                    thisRecord += ihLocal.ucToHexString(0x00 - (checksum & 0xFF));

                    /* Output the record                                      */
                    dataOut << thisRecord << endl;
                }
            }
                /* ...otherwise assume segment mode                               */
            else {
                if ((loadOffset >> 4) != addressOffset) {
                    std::uint8_t dataByte;

                    thisRecord.clear();
                    checksum = 0;

                    addressOffset = loadOffset;
                    addressOffset >>= 4;

                    thisRecord = ":02000002";
                    checksum = 0x02 + 0x02;

                    dataByte = static_cast<std::uint8_t>(addressOffset & 0xFF);
                    checksum += dataByte;
                    thisRecord += ihLocal.ucToHexString(dataByte);

                    dataByte = static_cast<std::uint8_t>((addressOffset >> 8) & 0xFF);
                    checksum += dataByte;
                    thisRecord += ihLocal.ucToHexString(dataByte);

                    thisRecord += ihLocal.ucToHexString(0x00 - (checksum & 0xFF));

                    /* Output the record                                      */
                    dataOut << thisRecord << endl;
                }
            }

            /* Prepare for encoding next data record                          */
            thisRecord.clear();
            checksum = 0;
            recordData.clear();

            /* We need to check where the data actually starts, but only the  */
            /* bottom 16-bits; the other bits are in the segment/linear       */
            /* address record                                                 */
            loadOffset = (*ihIterator).first & 0xFFFF;

            /* Loop through and collect up to 16 bytes of data                */
            for (int x = 0; x < 16; x++) {
                currentAddress = (*ihIterator).first & 0xFFFF;

                recordData.push_back((*ihIterator).second);

                ihIterator++;

                /* Check that we haven't run out of data                      */
                if (ihIterator == ihLocal.ihContent.end()) {
                    break;
                }

                /* Check that the next address is consecutive                 */
                previousAddress = currentAddress;
                currentAddress = (*ihIterator).first & 0xFFFF;
                if (currentAddress != (previousAddress + 1)) {
                    break;
                }

                /* If we got here we have a consecutive address and can keep  */
                /* building up the data portion of the data record            */
            }

            /* Now we should have some data to encode; check first            */
            if (recordData.size() > 0) {
                vector<std::uint8_t>::iterator itData;
                std::uint8_t dataByte;

                /* Start building data record                                 */
                thisRecord = ":";

                /* Start with the RECLEN record length                        */
                dataByte = static_cast<std::uint8_t>(recordData.size());
                thisRecord += ihLocal.ucToHexString(dataByte);
                checksum += dataByte;

                /* Then the LOAD OFFSET                                       */
                dataByte = static_cast<std::uint8_t>((loadOffset >> 8) & 0xFF);
                thisRecord += ihLocal.ucToHexString(dataByte);
                checksum += dataByte;
                dataByte = static_cast<std::uint8_t>(loadOffset & 0xFF);
                thisRecord += ihLocal.ucToHexString(dataByte);
                checksum += dataByte;

                /* Then the RECTYP record type (no need to add to checksum -  */
                /* value is zero '00'                                         */
                thisRecord += "00";

                /* Now we add the data                                        */
                for (itData = recordData.begin(); itData != recordData.end(); itData++) {
                    dataByte = (*itData);
                    checksum += dataByte;
                    thisRecord += ihLocal.ucToHexString(dataByte);
                }

                /* Last bit - add the checksum                                */
                thisRecord += ihLocal.ucToHexString(0x00 - (checksum & 0xFF));

                /* Now write the record                                       */
                dataOut << thisRecord << endl;
            }
        }
    }

    /* If there is a segment start address, output the data                   */
    if (ihLocal.startSegmentAddress.exists) {
        std::uint8_t dataByte;

        thisRecord.clear();
        checksum = 0;

        thisRecord = ":04000003";
        checksum = 0x04 + 0x03;

        dataByte = static_cast<std::uint8_t>((ihLocal.startSegmentAddress.csRegister >> 8) & 0xFF);
        checksum += dataByte;
        thisRecord += ihLocal.ucToHexString(dataByte);

        dataByte = static_cast<std::uint8_t>(ihLocal.startSegmentAddress.csRegister & 0xFF);
        checksum += dataByte;
        thisRecord += ihLocal.ucToHexString(dataByte);

        dataByte = static_cast<std::uint8_t>((ihLocal.startSegmentAddress.ipRegister >> 8) & 0xFF);
        checksum += dataByte;
        thisRecord += ihLocal.ucToHexString(dataByte);

        dataByte = static_cast<std::uint8_t>(ihLocal.startSegmentAddress.ipRegister & 0xFF);
        checksum += dataByte;
        thisRecord += ihLocal.ucToHexString(dataByte);


        /* Last bit - add the checksum                                        */
        thisRecord += ihLocal.ucToHexString(0x00 - (checksum & 0xFF));

        /* Now write the record                                               */
        dataOut << thisRecord << endl;
    }

    /* If there is a linear start address, output the data                    */
    if (ihLocal.startLinearAddress.exists) {
        std::uint8_t dataByte;

        thisRecord.clear();
        checksum = 0;

        thisRecord = ":04000005";
        checksum = 0x04 + 0x05;

        dataByte = static_cast<std::uint8_t>((ihLocal.startLinearAddress.eipRegister >> 24) & 0xFF);
        checksum += dataByte;
        thisRecord += ihLocal.ucToHexString(dataByte);

        dataByte = static_cast<std::uint8_t>((ihLocal.startLinearAddress.eipRegister >> 16) & 0xFF);
        checksum += dataByte;
        thisRecord += ihLocal.ucToHexString(dataByte);

        dataByte = static_cast<std::uint8_t>((ihLocal.startLinearAddress.eipRegister >> 8) & 0xFF);
        checksum += dataByte;
        thisRecord += ihLocal.ucToHexString(dataByte);

        dataByte = static_cast<std::uint8_t>(ihLocal.startLinearAddress.eipRegister & 0xFF);
        checksum += dataByte;
        thisRecord += ihLocal.ucToHexString(dataByte);


        /* Last bit - add the checksum                                        */
        thisRecord += ihLocal.ucToHexString(0x00 - (checksum & 0xFF));

        /* Now write the record                                               */
        dataOut << thisRecord << endl;
    }

    /* Whatever happened, we can always output the EOF record                 */
    dataOut << ":00000001FF" << endl;

    return (dataOut);
}

}
/*******************************************************************************
*
*                        INTEL HEX FILE CLASS MODULE END
*
*******************************************************************************/
